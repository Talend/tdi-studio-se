<%@ jet
imports="
    org.talend.core.model.process.INode
    org.talend.core.model.process.ElementParameterParser
    org.talend.designer.codegen.config.CodeGeneratorArgument
    java.util.List
    java.util.Map
    org.talend.core.model.utils.NodeUtil
"
%>

<%
    CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
    INode node = (INode)codeGenArgument.getArgument();
    String cid = node.getUniqueName();
    String remotedir = ElementParameterParser.getValue(node, "__REMOTEDIR__");
    List<Map<String, String>> filelist =(List<Map<String,String>>)ElementParameterParser.getObjectValue(node,"__FILELIST__");
    String authMethod = ElementParameterParser.getValue(node,"__AUTH_METHOD__");
    boolean isLog4jEnabled = ("true").equals(ElementParameterParser.getValue(node.getProcess(), "__LOG4J_ACTIVATE__"));
    String useExistingConn = ElementParameterParser.getValue(node, "__USE_EXISTING_CONNECTION__");
    if(("true").equals(useExistingConn)){
        String connection = ElementParameterParser.getValue(node, "__CONNECTION__");
        INode connectionNode = NodeUtil.getNodeByUniqueName(node.getProcess(), connection);
        authMethod = ElementParameterParser.getValue(connectionNode,"__AUTH_METHOD__");
    }
%>

        /* open a session */

        <%if(isLog4jEnabled){%>
            log.info("<%=cid%> - Open up a session.");
        <%}%>

        session_<%=cid%> = client_<%=cid%>.connect(username_<%=cid%>, hostname_<%=cid%>, port_<%=cid%>).verify().getClientSession();
    try {
        session_<%=cid%>.auth().verify();
    }catch (org.apache.sshd.common.SshException se_<%=cid%>){
        globalMap.put("<%=cid %>_EXIT_CODE",se_<%=cid%>.getDisconnectCode());
    <%
    if (("PUBLICKEY").equals(authMethod)) {
    %>
        java.nio.file.Files.write(privateKey_<%=cid%>,lines_<%=cid%>);
    <%}%>
        if(14 == se_<%=cid%>.getDisconnectCode()){
            throw new IllegalArgumentException("Authentication failed.");
        }else{
            throw se_<%=cid%>;
        }
    }
            org.apache.sshd.client.scp.ScpClientCreator instance_<%=cid%> = org.apache.sshd.client.scp.ScpClientCreator.instance();
                                        org.apache.sshd.client.scp.DefaultScpClient scp_<%=cid%> = new org.apache.sshd.client.scp.DefaultScpClient(session_<%=cid%>, instance_<%=cid%>.getScpFileOpener(),
                                        instance_<%=cid%>.getScpTransferEventListener()) {
                                                      @Override
                                                      public void upload(java.io.InputStream local, String remote, long size, java.util.Collection<java.nio.file.attribute.PosixFilePermission> perms, org.apache.sshd.common.scp.ScpTimestamp time)
                                                              throws java.io.IOException {
                                                          int namePos = org.apache.sshd.common.util.ValidateUtils.checkNotNullAndNotEmpty(remote, "No remote location specified").lastIndexOf('/');
                                                          String name = (namePos < 0)
                                                                  ? remote
                                                                  : org.apache.sshd.common.util.ValidateUtils.checkNotNullAndNotEmpty(remote.substring(namePos + 1), "No name value in remote=%s", remote);
                                                          java.util.Collection<Option> options = (time != null) ? java.util.EnumSet.of(org.apache.sshd.client.scp.ScpClient.Option.PreserveAttributes) : java.util.Collections.emptySet();
                                                          String cmd = org.apache.sshd.client.scp.ScpClient.createSendCommand(remote, options);
                                                          org.apache.sshd.client.session.ClientSession session = getClientSession();
                                                          org.apache.sshd.client.channel.ChannelExec channel = openCommandChannel(session, cmd);
                                                          try (java.io.InputStream invOut = channel.getInvertedOut();
                                                                  java.io.OutputStream invIn = channel.getInvertedIn()) {
                                                              // NOTE: we use a mock file system since we expect no invocations for it
                                                        org.apache.sshd.common.scp.ScpHelper helper = new org.apache.sshd.common.scp.ScpHelper(session, invOut, invIn, new org.apache.sshd.common.file.util.MockFileSystem(remote), opener, listener) {


                                                                          public int readAck(boolean canEof) throws IOException {
                                                                              int c = in.read();
                                                                              switch (c) {
                                                                              case -1:
                                                                                  if (log.isDebugEnabled()) {
                                                                                      log.debug("readAck({})[EOF={}] received EOF", this, canEof);
                                                                                  }
                                                                                  if (!canEof) {
                                                                                      throw new java.io.EOFException("readAck - EOF before ACK");
                                                                                  }
                                                                                  break;
                                                                              case org.apache.sshd.common.scp.ScpHelper.OK:
                                                                                  if (log.isDebugEnabled()) {
                                                                                      log.debug("readAck({})[EOF={}] read OK", this, canEof);
                                                                                  }
                                                                                  break;
                                                                              case org.apache.sshd.common.scp.ScpHelper.WARNING: {
                                                                                  if (log.isDebugEnabled()) {
                                                                                      log.debug("readAck({})[EOF={}] read warning message", this, canEof);
                                                                                  }

                                                                                  String line = readLine();
                                                                                  log.warn("readAck({})[EOF={}] - Received warning: {}", this, canEof, line);
                                                                                  throw new org.apache.sshd.common.scp.ScpException("received error: " + line, c);
                                                                              }
                                                                              case org.apache.sshd.common.scp.ScpHelper.ERROR: {
                                                                                  if (log.isDebugEnabled()) {
                                                                                      log.debug("readAck({})[EOF={}] read error message", this, canEof);
                                                                                  }
                                                                                  String line = readLine();
                                                                                  if (log.isDebugEnabled()) {
                                                                                      log.debug("readAck({})[EOF={}] received error: {}", this, canEof, line);
                                                                                  }
                                                                                  throw new org.apache.sshd.common.scp.ScpException("Received nack: " + line, c);
                                                                              }
                                                                              default:
                                                                                  break;
                                                                              }
                                                                              return c;
                                                                          }
                                                                      };
                                                              java.nio.file.Path mockPath = new org.apache.sshd.common.file.util.MockPath(remote);
                                                              helper.sendStream(new org.apache.sshd.client.scp.DefaultScpStreamResolver(name, mockPath, perms, time, size, local, cmd),
                                                                      options.contains(Option.PreserveAttributes), org.apache.sshd.common.scp.ScpHelper.DEFAULT_SEND_BUFFER_SIZE);
                                                              handleCommandExitStatus(cmd, channel);
                                                          } finally {
                                                              channel.close(false);
                                                          }
                                                      }
                                        };

    String[] destFileNames_<%=cid%> = new String[]{
     <%
        for (Map<String, String> file : filelist) {
     %>
            <%=file.get("DESTINATION")%>,
     <%
        }
     %>
   };
    <%if(isLog4jEnabled){%>
        log.info("<%=cid%> - Truncating file from the server.");
    <%}%>
   for(String destFile_<%=cid %> : destFileNames_<%=cid%>){
    try{
           if(destFile_<%=cid %>!=null && destFile_<%=cid %>.length()!=0){
               java.util.List<java.nio.file.attribute.PosixFilePermission> posixFilePermissions = java.util.Arrays.asList(java.nio.file.attribute.PosixFilePermission.OWNER_READ,
               java.nio.file.attribute.PosixFilePermission.OWNER_WRITE,
               java.nio.file.attribute.PosixFilePermission.GROUP_READ,
               java.nio.file.attribute.PosixFilePermission.OTHERS_READ);
               scp_<%=cid%>.upload(new byte[0],<%=remotedir%>+"/"+destFile_<%=cid %>,posixFilePermissions,new org.apache.sshd.common.scp.ScpTimestamp(System.nanoTime(),System.nanoTime()));
               nb_file_<%=cid%> ++;
               globalMap.put("<%=cid %>_STATUS", "File truncate OK.");
           }
       }catch(java.lang.Exception e){
            globalMap.put("<%=cid %>_STATUS", "File truncate fail.");
       }
   }
   session_<%=cid%>.close();